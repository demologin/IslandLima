package com.javarush.island.mokropolov.entity;import com.javarush.island.mokropolov.entity.interfaces.Reproducible;import com.javarush.island.mokropolov.game.EntityPrefs;import com.javarush.island.mokropolov.game.GamePreference;import com.javarush.island.mokropolov.game.Randomizer;import com.javarush.island.mokropolov.game.map.Cell;import java.util.*;import java.util.concurrent.atomic.AtomicLong;public abstract class Entity implements Reproducible, Cloneable {    private final static AtomicLong idCounter = new AtomicLong(System.currentTimeMillis());    private long id = idCounter.incrementAndGet();    private String name, image;    String type = this.getClass().getSimpleName();    private double foodWeight, weight, maxWeight, maxFood;    private int maxCount, speed;    public Entity(EntityPrefs entityPrefs) {        this.name = entityPrefs.getName();        this.image = entityPrefs.getImage();        this.maxWeight = entityPrefs.getMaxWeight();        this.maxCount = entityPrefs.getMaxCount();        this.speed = entityPrefs.getSpeed();        this.foodWeight = entityPrefs.getFoodWeight();        this.weight = entityPrefs.getWeight();        this.maxFood = entityPrefs.getMaxWeight() - entityPrefs.getWeight();    }    protected Entity clone() throws CloneNotSupportedException {       Entity clone = (Entity) super.clone();       clone.id = idCounter.incrementAndGet();        return (Entity) super.clone();    }    public static <T extends Entity> T clone (T original){        try {            return  (T) original.clone();        } catch (CloneNotSupportedException e) {            throw new RuntimeException(e);        }    }    protected boolean safeDie(Cell target) {        target.getLock().lock();        try {            return target.getCellsEntities().get(type).remove(this);        } finally {            target.getLock().unlock();        }    }    protected boolean safeChangeWeight(Cell currentCell, int percent) {        currentCell.getLock().lock();        try {            double maxWeight = getMaxWeight();            weight += maxWeight * percent / 100;            weight = Math.max(0, weight);            weight = Math.min(weight, maxWeight);            return currentCell.getCellsEntities().get(type).contains(this);        } finally {            currentCell.getLock().unlock();        }    }    protected boolean safeMove(Cell cell, Cell destination) {        if (safeAddTo(destination)) { //if was added            if (safePollFrom(cell)) { //and after was extract                return true; //ok            } else {                safePollFrom(destination); //die or eaten            }        }        return false;    }    protected boolean safeAddTo(Cell cell) {        cell.getLock().lock();        try {            Set<Entity> set = cell.getCellsEntities().get(this.getName());            int maxCount = getMaxCount();            int size = set.size();            return size < maxCount && set.add(this);        } finally {            cell.getLock().unlock();        }    }    protected boolean safePollFrom(Cell cell) {        cell.getLock().lock();        try {            return cell.getCellsEntities().get(getName()).remove(this);        } finally {            cell.getLock().unlock();        }    }    protected boolean safeFindFood(Cell currentCell) {        currentCell.getLock().lock();        boolean success = false;        try {            double needFood = getNeedFood();            if ((needFood > 0)) {                //Map<String, Integer> entry = GamePreference.eatingProbability.get(this.type);                var foodMap = GamePreference.eatingProbability. get(getName()).entrySet();                var iterator = foodMap.iterator();                while (needFood > 0 && iterator.hasNext()) {                    Map.Entry<String, Integer> entry = iterator.next();                    String keyFood = entry.getKey();                    Integer probably = entry.getValue();                    var foods = currentCell.getCellsEntities().get(keyFood);                    if (foods.size() > 0 && probably > Randomizer.random(0, 100)) {                        for (Iterator<Entity> organismIterator = foods.iterator(); organismIterator.hasNext(); ) {                            Entity foodsEntity = organismIterator.next();                            double foodWeight = foodsEntity.getWeight();                            double delta = Math.min(foodWeight, needFood);                            double weight = getWeight();                            setWeight(weight + delta);                            foodsEntity.setWeight(foodWeight - delta);                            if (foodsEntity.getWeight() <= foodsEntity.maxWeight / 5) {                                organismIterator.remove();                            }                            needFood -= delta;                            success = true;                            if (needFood <= 0) {                                return true;                            }                        }                    }                }            }        } finally {            currentCell.getLock().unlock();        }        return success;    }    @Override    public boolean equals(Object o) {        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Entity organism = (Entity) o;        return id == organism.id;    }    private double getNeedFood() {        return Math.min(getMaxFood(), getMaxWeight() - getWeight());    }    @Override    public int hashCode() {        return Objects.hash(id);    }    public String getName() {return name;}    public String getImage() { return image;}    public double getWeight() { return weight;}    public double getMaxWeight() {        return maxWeight;    }    public int getMaxCount() {        return maxCount;    }    public int getSpeed() {        return speed;    }    public String getType() {        return type;    }    public double getMaxFood() {        return maxFood;    }    public void setWeight(double weight) {        this.weight = weight;    }}