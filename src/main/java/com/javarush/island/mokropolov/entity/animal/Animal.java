package com.javarush.island.mokropolov.entity.animal;import com.javarush.island.mokropolov.entity.Entity;import com.javarush.island.mokropolov.entity.interfaces.Eating;import com.javarush.island.mokropolov.entity.interfaces.Movable;import com.javarush.island.mokropolov.entity.interfaces.Reproducible;import com.javarush.island.mokropolov.game.EntityPrefs;import com.javarush.island.mokropolov.game.map.Cell;import java.util.Set;public abstract class Animal extends Entity implements Eating, Reproducible, Movable {    public Animal(EntityPrefs entityPrefs) {        super(entityPrefs);    }    @Override    public boolean eat(Cell currentCell) {        if (safeFindFood(currentCell)) {            return true;        }        if (getWeight() > 0) {            return safeChangeWeight(currentCell, -5);        } else return !safeDie(currentCell);    }    @Override    public boolean move(Cell startCell) {        int steps = this.getSpeed();        Cell destCell = startCell.getNextCell(steps);        return safeMove(startCell, destCell);    }    @Override    public boolean multiply(Cell cell) {        return safeMultiply(cell);    }    private boolean safeMultiply(Cell cell) {        cell.getLock().lock();        try {            Set<Entity> entities = cell.getCellsEntities().get(getType());            double maxWeight = getMaxWeight();            if (getWeight() > maxWeight / 2 &&                    entities.contains(this) &&                    entities.size() > 1 &&                    entities.size() < getMaxCount()            ) {                double childWeight = getWeight() / 2;                setWeight(getWeight() / 2);                Entity clone = Entity.clone(this);                clone.setWeight(childWeight);                entities.add(clone);                return true;            }        } finally {            cell.getLock().unlock();        }        return false;    }}