package com.javarush.island.mokropolov.game.threads;import com.javarush.island.mokropolov.entity.Entity;import com.javarush.island.mokropolov.game.map.Cell;import com.javarush.island.mokropolov.game.map.GameMap;import java.util.Objects;import java.util.Queue;import java.util.Set;import java.util.concurrent.ConcurrentLinkedQueue;public class EntityWorker implements Runnable{    private final Entity prototype;    private final GameMap gameMap;    private final Queue<Task> tasks = new ConcurrentLinkedQueue<>();    public EntityWorker(Entity entity, GameMap gameMap) {        this.prototype = entity;        this.gameMap = gameMap;    }    @Override    public void run() {        Cell[][] cells = gameMap.getCells();        for (Cell[] row : cells) {            for (Cell cell : row) {                try {                    processOneCell(cell);                }catch (Exception e){                    e.printStackTrace();                    System.err.println("Need debug!!!!");                    return;                }            }        }    }    private void processOneCell (Cell cell){        String type = prototype.getName();        Set<Entity> entitySet = cell.getCellsEntities().get(type);        if (Objects.nonNull(entitySet)){            cell.getLock().lock();            try{                entitySet.forEach(entity -> {                    Task task = new Task(entity, cell);                    tasks.add(task);                });            }finally {                cell.getLock().unlock();            }            tasks.forEach(Task::execute);            tasks.clear();        }    }}