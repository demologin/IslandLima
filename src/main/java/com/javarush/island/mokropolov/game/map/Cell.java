package com.javarush.island.mokropolov.game.map;import com.javarush.island.mokropolov.entity.Entity;import com.javarush.island.mokropolov.game.Randomizer;import java.util.*;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class Cell {    private final Map<String, Set<Entity>> cellsEntities = new HashMap<>(){        private void checkNull(Object key) {            this.putIfAbsent(key.toString(), new HashSet<>());        }        @Override        public Set<Entity> get(Object key) {            checkNull(key);            return super.get(key);        }        @Override        public Set<Entity> put(String key, Set<Entity> value) {            checkNull(key);            return super.put(key, value);        }    };    private final Lock lock = new ReentrantLock(true);    private final List<Cell> nextCells = new ArrayList<>();    public Cell() {    }    public void loadNextCell(GameMap gameMap, int currentRow, int currentCol) {        Cell[][] cells = gameMap.getCells();        if (currentRow > 0) nextCells.add(cells[currentRow - 1][currentCol]);        if (currentCol > 0) nextCells.add(cells[currentRow][currentCol - 1]);        if (currentRow < cells.length - 1) nextCells.add(cells[currentRow + 1][currentCol]);        if (currentCol < cells[0].length - 1) nextCells.add(cells[currentRow][currentCol + 1]);    }    public Cell getNextCell(int steps) {        Set<Cell> roadCells = new HashSet<>();        Cell currentCell = this;        while (roadCells.size() < steps) {            var nextCells = currentCell.                    nextCells.stream().filter(cell -> !roadCells.contains(this)).                    toList();            int countDirection = nextCells.size();            if (countDirection > 0) {                int nextIndex = Randomizer.random(0, countDirection);                currentCell = nextCells.get(nextIndex);                roadCells.add(currentCell);            }            else{                break;            }        }        return currentCell;    }    public Map<String, Set<Entity>> getCellsEntities() {        return cellsEntities;    }    public Lock getLock() {        return lock;    }}